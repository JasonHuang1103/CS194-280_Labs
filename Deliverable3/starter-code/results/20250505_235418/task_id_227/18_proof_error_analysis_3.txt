Below is an explanation that goes through the error step‐by‐step.

───────────────────────────── 
1. Identifying the Failing Tactic

The error message shows “unsolved goals” in the two cases generated by the by_cases tactic. In your proof you write

  by_cases h : a ≤ min b c  
  · rw if_pos h  
    …  
  · rw if_neg h  
    …

Here the “·” (bullet) tokens signal the beginning of each case’s proof. Lean complains that “unsolved goals” remain and then later “unexpected token ‘·’”, meaning that it was not expecting another bullet because the tactic script in one of the cases wasn’t finished. In short, the tactic that “fails” is the use of the bullet notation in connection with the split case analysis: some subgoals generated by your tactic sequence left Lean “hanging” (unsolved) and the proof script isn’t properly terminated in each branch.

───────────────────────────── 
2. Considering the Proof State

When you unfold minOfThree and minOfThree_spec and then perform by_cases on (a ≤ min b c), two goals are created:
 • one in which h : a ≤ min b c holds, and the “if” collapses to a;
 • one in which h : ¬ (a ≤ min b c) holds, meaning the “if” becomes min b c.

In the first branch (the “true” or pos case) the goal becomes to prove:
  (a ≤ a ∧ a ≤ b ∧ a ≤ c) ∧ (a = a ∨ a = b ∨ a = c)
After rewriting with rw if_pos h, you then split the goal and use split tactics to prove each conjunct. At least on paper that is what you want to do. However, if any one of these split parts is left unsolved then Lean still considers that a goal remains.

In the second branch (the “neg” case) after rw if_neg h your goal is:
  (min b c ≤ a ∧ min b c ≤ b ∧ min b c ≤ c) ∧ (min b c = a ∨ min b c = b ∨ min b c = c)
There you use the tactic “apply le_of_not_le h” in one of your splits. (More on that below.) Also, you then do a case split on (le_total b c). If the two mini-cases for b and c are not correctly finished (or if their bullet structure is not well indented/aligned), then Lean will complain with an “unexpected token” error.

───────────────────────────── 
3. Matching the Proof Approach to the Specification

Your overall plan is correct: you want to show that minOfThree returns a number that is both less than or equal to each of a, b, and c and that it equals one of them. In the “if” branch, assuming a ≤ min b c, the function returns a and you use easy tactics (like le_rfl and le_trans combined with the properties of min) to show both parts.

In the “else” branch, the function returns min b c. There you need to prove:
 – that min b c is ≤ a, b, c (and note that a is now larger than min b c because the assumption is ¬ (a ≤ min b c)),
 – and that min b c equals b or equals c.
Your use of the standard theorems min_le_left/min_le_right and the rewriting lemmas like min_eq_left/min_eq_right is sensible. However, when you try to “apply le_of_not_le h” to prove min b c ≤ a, you may be assuming (or trying to use) a theorem that is not available or improperly applied. (In a total order you do have that if ¬ (x ≤ y) then y ≤ x—but the actual theorem name and usage must exactly match what Lean expects.) 

Furthermore, you later do a case split on le_total b c by “cases le_total b c with hb hc” and then use bullet notation for each subcase. If these bullets are not correctly nested or if the tactic “cases” does not automatically close off its subgoals, Lean will complain that you have unsolved goals.

───────────────────────────── 
4. Type Mismatches or Incorrect Assumptions

Notice that in your statement Lean shows “b ⊓ c” (read “b inf c”) in the error message instead of “min b c”. This is because for integers, the “min” function can be (and is) identified with the lattice infimum. All of your lemmas (min_le_left, min_le_right, min_eq_left, min_eq_right) need to be the correct ones for Int (or ℤ) seen as a total order/lattice. Also check that the “le_of_not_le” you are using is actually available and its type exactly fits the task of proving (min b c) ≤ a from the hypothesis h : ¬ (a ≤ min b c). (In a total order, from ¬ (x ≤ y) you can typically conclude y < x and then get y ≤ x by reflexivity—even though you might need a special lemma for that.) A wrong application here might leave a goal open.

───────────────────────────── 
5. Alternative Proof Strategies

A few suggestions to clean things up:
 – Instead of using the bullet “·” notation (which is sometimes finicky in Lean 4 when mixed with “by” blocks), try using “case pos” and “case neg” explicitly. For example:

  by_cases h : a ≤ min b c
  case inl =>
   rw if_pos h
   …  -- complete this branch
  case inr =>
   rw if_neg h
   …  -- complete the other branch

 – Alternatively, you can rewrite the proof with match or by doing a more “one‐go” proof where you distinguish the two possibilities.
 – Finally, check the use of “le_of_not_le h”. If such a lemma is not in scope, you might instead note that for integers (a total order) if a is not less than or equal to min b c then it must be that min b c < a (which easily gives min b c ≤ a).

───────────────────────────── 
Conclusion and Root Cause

The error is not in the definition of minOfThree or its specification per se but in the tactic script. In the branch analysis you’ve written bullet “·” steps that leave some subgoals unsolved. In particular:
 • One of the proofs (or splits) in each branch is incomplete because the tactics either rely on a non‐existent or misapplied lemma (like using “le_of_not_le h”) or because the bullet notation is not correctly nested.
 • Also, writing “min b c” causes Lean to display “b ⊓ c” (its lattice form), so you have to be careful that the rewriting lemmas (min_eq_left and min_eq_right) match the actual definitions for Int.

To fix the error you should:
 – Make sure that every branch produced by by_cases ends with all the subgoals solved. Check that each bullet properly “closes” its case.
 – Either re-indent or remove the stray bullet “·” tokens and consider using “case inl / inr” syntax for clarity.
 – Replace or justify the use of “apply le_of_not_le h” by using the correct lemma that, in a total order on ℤ, shows that if a is not ≤ (min b c) then (min b c) ≤ a.

Once these points are fixed, Lean will no longer complain about “unsolved goals” or an “unexpected token”.

───────────────────────────── 
Summary

The root cause is that in your by_cases proof you left some subgoals unsolved due to improper bullet structure and possibly an incorrect use of a “le_of_not_le” style lemma. The bullets (the “·” tokens) are not correctly nested with the underlying case splits, so Lean finds that after one branch there is an unexpected token and incomplete proofs. Fix the structure of your proof (for example, by using more explicit case labels or reordering your bullet levels) and check the statements of your auxiliary lemmas to resolve type mismatches.

This should be your direction for fixing the proof.