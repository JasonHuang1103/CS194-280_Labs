[CLS] arrays the lean language reference the lean language reference table of contents 1. introduction 2. elaboration and compilation 3. interacting with lean 4. the type system 5. source files and modules 6. namespaces and sections 7. definitions 8. axioms 9. attributes 10. terms 11. type classes 12. coercions 13. tactic proofs 14. functors, monads and do - notation 15. io 16. the simplifier 17. basic propositions 18. basic types 19. notations and macros 20. run - time code 21. build tools and distribution release notes index 18. basic types 18. 1. natural numbers 18. 2. integers 18. 3. finite natural numbers 18. 4. fixed - precision integers 18. 5. bitvectors 18. 6. floating - point numbers 18. 7. characters 18. 8. strings 18. 9. the unit type 18. 10. the empty type 18. 11. booleans 18. 12. optional values 18. 13. tuples 18. 14. sum types 18. 15. linked lists 18. 16. arrays 18. 17. subtypes 18. 18. lazy computations 18. 16. arrays 1. logical model array 2. run
use the by _ cases tactic. example ( p : prop ) : ¬¬ p → p : = by intro h by _ cases h ' : p · assumption contradiction notice that the by _ cases tactic lets you specify a label for the hypothesis that is introduced in each branch, in this case, h ' : p in one and h ' : ¬ p in the other. if you leave out the label, lean uses h by default. try proving the following equivalence, using by _ cases to establish one direction. example ( p q : prop ) : p → q ↔ ¬ p ∨ q : = by sorry 3. 6. sequences and convergence we now have enough skills at our disposal to do some real mathematics. in lean, we can represent a sequence \ ( s _ 0, s _ 1, s _ 2, \ ldots \ ) of real numbers as a function s : [UNK] → ℝ. such a sequence is said to converge to a number \ ( a \ ) if for every \ ( \ varepsilon > 0 \ ) there is a point beyond which the sequence remains within \ ( \ varepsilon \ ) of \ ( a \ ), that is, there is a number \ ( n \ ) such that for every \
push ( f arr [ i ] ) ) ( i + 1 ) else sofar failed to prove index is valid, possible solutions : - use ` have ` - expressions to prove the index is valid - use ` a [ i ]! ` notation instead, runtime check is perfomed, and ' panic ' error message is produced if index is not valid - use ` a [ i ]? ` notation instead, result is an ` option ` type - use ` a [ i ] ' h ` notation instead, where ` h ` is a proof that index is valid α : type? u. 1704 β : type? u. 1707 f : α → β arr : array α sofar : array β i : nat [UNK] i < array. size arr however, the conditional expression already checks the precise condition that the array index ' s validity demands ( namely, i < arr. size ). adding a name to the if resolves the issue, because it adds an assumption that the array indexing tactic can use : def arraymaphelper ( f : α → β ) ( arr : array α ) ( sofar : array β ) ( i : nat ) : array β : = if inbounds : i < ar