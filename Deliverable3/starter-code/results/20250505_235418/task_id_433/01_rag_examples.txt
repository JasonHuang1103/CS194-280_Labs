: α ) : ( replicate n a ). length = n : = by let rec aux ( n : nat ) ( as : list α ) : ( replicate. loop a n as ). length = n + as. length : = by match n with | 0 = > simp [ replicate. loop ] | n + 1 = > simp [ replicate. loop, aux n, nat. add _ succ, nat. succ _ add ] exact aux n [ ] you can also introduce auxiliary recursive declarations using a where clause after your definition. lean converts them into a let rec : def replicate ( n : nat ) ( a : α ) : list α : = loop n [ ] where loop : nat → list α → list α | 0, as = > as | n + 1, as = > loop n ( a : : as ) theorem length _ replicate ( n : nat ) ( a : α ) : ( replicate n a ). length = n : = by exact aux n [ ] where aux ( n : nat ) ( as : list α ) : ( replicate. loop a n as ). length = n + as. length : = by match n with | 0 = > simp [ replicate.
##cards is common in functional programming languages, and so lean adopts that notation. section wildcards and overlapping patterns expands on the notion of a wildcard, and section inaccessible patterns explains how you can use implicit arguments in patterns as well. as described in chapter inductive types, inductive data types can depend on parameters. the following example defines the tail function using pattern matching. the argument α : type u is a parameter and occurs before the colon to indicate it does not participate in the pattern matching. lean also allows parameters to occur after :, but it cannot pattern match on them. def tail1 { α : type u } : list α → list α | [ ] = > [ ] | a : : as = > as def tail2 : { α : type u } → list α → list α | α, [ ] = > [ ] | α, a : : as = > as despite the different placement of the parameter α in these two examples, in both cases it is treated in the same way, in that it does not participate in a case split. lean can also handle more complex forms of pattern matching, in which arguments to dependent types pose additional constraints on the various cases. such examples of dependent pattern matching are considered in the section dependent
n + 1, as = > loop n ( a : : as ) loop n [ ] # check @ replicate. loop - - { α : type } → α → nat → list α → list α lean creates an auxiliary declaration for each let rec. in the example above, it created the declaration replicate. loop for the let rec loop occurring at replicate. note that, lean " closes " the declaration by adding any local variable occurring in the let rec declaration as additional parameters. for example, the local variable a occurs at let rec loop. you can also use let rec in tactic mode and for creating proofs by induction. def replicate ( n : nat ) ( a : α ) : list α : = let rec loop : nat → list α → list α | 0, as = > as | n + 1, as = > loop n ( a : : as ) loop n [ ] theorem length _ replicate ( n : nat ) ( a : α ) : ( replicate n a ). length = n : = by let rec aux ( n : nat ) ( as : list α ) : ( replicate. loop a n as ). length = n + as. length : = by match n with | 0 = > simp [ replicate. loop