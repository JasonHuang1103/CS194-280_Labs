still want to structure the proof. lean also provides the " bullet " notation. < tactics > ( or · < tactics > ) for structuring proofs : theorem test ( p q : prop ) ( hp : p ) ( hq : q ) : p ∧ q ∧ p : = by apply and. intro. exact hp. apply and. intro. exact hq. exact hp basic tactics in addition to apply and exact, another useful tactic is intro, which introduces a hypothesis. what follows is an example of an identity from propositional logic that we proved in a previous chapter, now proved using tactics. example ( p q r : prop ) : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) : = by apply iff. intro. intro h apply or. elim ( and. right h ). intro hq apply or. inl apply and. intro. exact and. left h. exact hq. intro hr apply or. inr apply and. intro. exact and. left h. exact hr. intro h apply or. elim h. intro hpq apply and. intro. exact and. left hpq. apply or. inl exact and. right hpq. intro hpr apply
excluded middle. the full list of axioms that are used in lean to support classical reasoning are discussed in axioms and computation. examples of propositional validities lean ' s standard library contains proofs of many valid statements of propositional logic, all of which you are free to use in proofs of your own. the following list includes a number of common identities. commutativity : p ∧ q ↔ q ∧ p p ∨ q ↔ q ∨ p associativity : ( p ∧ q ) ∧ r ↔ p ∧ ( q ∧ r ) ( p ∨ q ) ∨ r ↔ p ∨ ( q ∨ r ) distributivity : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) p ∨ ( q ∧ r ) ↔ ( p ∨ q ) ∧ ( p ∨ r ) other properties : ( p → ( q → r ) ) ↔ ( p ∧ q → r ) ( ( p ∨ q ) → r ) ↔ ( p → r ) ∧ ( q → r ) ¬ ( p ∨ q ) ↔ ¬p ∧ ¬q ¬p ∨ ¬q → ¬ ( p ∧ q ) ¬ ( p ∧ ¬p ) p ∧ ¬q → ¬ ( p → q
: = nat. le _ trans [UNK] f 1 ≥ f 2 › [UNK] f 0 ≥ f 1 › have : f 0 ≤ f 2 : = nat. le _ trans ( h 0 ) ( h 1 ) show f 0 = f 2 from nat. le _ antisymm this [UNK] f 0 ≥ f 2 › keep in mind that you can use the french quotation marks in this way to refer to anything in the context, not just things that were introduced anonymously. its use is also not limited to propositions, though using it for data is somewhat odd : example ( n : nat ) : nat : = [UNK] nat › later, we show how you can extend the proof language using the lean macro system. exercises prove these equivalences : variable ( α : type ) ( p q : α → prop ) example : ( [UNK] x, p x ∧ q x ) ↔ ( [UNK] x, p x ) ∧ ( [UNK] x, q x ) : = sorry example : ( [UNK] x, p x → q x ) → ( [UNK] x, p x ) → ( [UNK] x, q x ) : = sorry example : ( [UNK] x, p x ) ∨ ( [UNK] x, q x ) → [UNK] x, p x ∨ q x : =