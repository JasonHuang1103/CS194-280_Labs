assoc ( a * a ) ] _ = a * a + 2 * ( a * b ) + b * b : = by rw [ mul _ comm b a, ← two _ mul ] notice that the proof does not begin with by : an expression that begins with calc is a proof term. a calc expression can also be used inside a tactic proof, but lean interprets it as the instruction to use the resulting proof term to solve the goal. the calc syntax is finicky : the underscores and justification have to be in the format indicated above. lean uses indentation to determine things like where a block of tactics or a calc block begins and ends ; try changing the indentation in the proof above to see what happens. one way to write a calc proof is to outline it first using the sorry tactic for justification, make sure lean accepts the expression modulo these, and then justify the individual steps using tactics. example : ( a + b ) * ( a + b ) = a * a + 2 * ( a * b ) + b * b : = calc ( a + b ) * ( a + b ) = a * a + b * a + ( a * b +
still want to structure the proof. lean also provides the " bullet " notation. < tactics > ( or · < tactics > ) for structuring proofs : theorem test ( p q : prop ) ( hp : p ) ( hq : q ) : p ∧ q ∧ p : = by apply and. intro. exact hp. apply and. intro. exact hq. exact hp basic tactics in addition to apply and exact, another useful tactic is intro, which introduces a hypothesis. what follows is an example of an identity from propositional logic that we proved in a previous chapter, now proved using tactics. example ( p q r : prop ) : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) : = by apply iff. intro. intro h apply or. elim ( and. right h ). intro hq apply or. inl apply and. intro. exact and. left h. exact hq. intro hr apply or. inr apply and. intro. exact and. left h. exact hr. intro h apply or. elim h. intro hpq apply and. intro. exact and. left hpq. apply or. inl exact and. right hpq. intro hpr apply
≤ y ∧ ¬ y ≤ x : = by rintro ⟨ h₀, h₁ ⟩ use h₀ exact fun h ' ↦ h₁ ( le _ antisymm h₀ h ' ) in the first example, the semicolon after the constructor command tells lean to use the norm _ num tactic on both of the goals that result. in lean, a ↔ b is not defined to be ( a → b ) ∧ ( b → a ), but it could have been, and it behaves roughly the same way. you have already seen that you can write h. mp and h. mpr or h. 1 and h. 2 for the two directions of h : a ↔ b. you can also use cases and friends. to prove an if - and - only - if statement, you can use constructor or angle brackets, just as you would if you were proving a conjunction. example { x y : ℝ } ( h : x ≤ y ) : ¬ y ≤ x ↔ x = y : = by constructor · contrapose! rintro rfl rfl contrapose! exact le _ antisymm h example { x y : ℝ } ( h : x ≤ y ) : ¬ y ≤ x ↔ x