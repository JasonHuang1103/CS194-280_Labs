Below is a step‐by‐step explanation of what goes wrong and why the error “unsolved goals” (and later “unexpected identifier”) appears, followed by suggestions on how to fix it.

─────────────────────────────  
1. Identifying the Failing Tactic

• In your proof you use
  unfold myMin myMin_spec  
  split_ifs with h  
  case pos => …  
  case neg => …  
The error “unsolved goals” shows that after “split_ifs”, Lean has generated one case when h holds (i.e. a ≤ b) and one when h fails. In each branch your script uses multiple calls of the tactic constructor and then exact. One or more of these tactic calls does not “close” its goal. (Then later, when Lean sees “case neg =>” it complains “unexpected identifier” because it wasn’t expecting an extra branch when there is still an open goal.)

─────────────────────────────  
2. Considering the Proof State

• In the “pos” branch (with h : a ≤ b) the unfolded goal is
  (a ≤ a ∧ a ≤ b) ∧ (a = a ∨ a = b).
You first call “constructor” which tells Lean to prove an ∧ statement by supplying the two conjuncts. Then you use a second “constructor”: your intent is to supply the two parts of (a ≤ a ∧ a ≤ b) by proving a ≤ a and a ≤ b. Finally you use “exact Or.inl rfl” to prove the disjunction (a = a ∨ a = b).

• However, the error tells us that at least one of these subgoals is “unsolved.” (A similar situation happens in the “neg” branch.) At the moment after “split_ifs” the tactic state has two goals lingering, and your series of tactics does not eliminate all of them.

─────────────────────────────  
3. Checking that the Proof Approach Matches the Specification

• Your specification is:
  myMin_spec a b result :=
   (result ≤ a ∧ result ≤ b) ∧ (result = a ∨ result = b)
for result = myMin a b.
You are doing a case split on the if–then–else inside myMin. In each branch you want to prove a conjunction whose first component is also a conjunction. Your idea (to use “constructor” twice and then an “exact”) is perfectly acceptable in principle—but only if each nested goal is correctly addressed and no goal remains partially unsolved. The error indicates that Lean’s goal state did not end up “all solved” by the end of one of the branches.

─────────────────────────────  
4. Looking for Type Mismatches or Incorrect Assumptions

• There isn’t a type mismatch in the definitions: both parts of your specification are what you expect.
• However, one “incorrect assumption” is that your tactic script’s “constructor” calls automatically and in sequence apply to the right sub-goals. In Lean 4 it is very easy (especially without bullet notation) to accidentally leave a subgoal unsolved because the tactic context becomes ambiguous.
• In particular, after “split_ifs with h” the generated elimination might expect you to prove 
 ( (a ≤ a ∧ a ≤ b) → (a = a ∨ a = b) → _ )
or have separate subgoals. In our case, Lean highlights that when you complete one branch (say “case pos”), there remain open subgoals that you never discharged.

─────────────────────────────  
5. Considering Alternative Strategies

• Use bullet notation. Bullets (or the · notation) clearly mark which tactics go to which goal. For example, writing
  split_ifs with h
  · -- case when h holds
   apply And.intro
     · exact le_refl a
     · exact h
   apply Or.inl; exact rfl
  · -- case when h does not hold
   …
will assure Lean that each branch is completed.
  
• Alternatively, you could avoid “unfold” and “split_ifs” altogether by doing a case analysis on the boolean condition. For example, you could do “by cases decidable.em (a ≤ b)” or similar.

• You might also consider writing the layered conjunction using “apply And.intro” with separate tactics for each conjunct. That can make it clearer which subgoal remains open.

─────────────────────────────  
Detailed Analysis of the Root Cause and How to Fix It

The error essentially comes down to one primary issue: after “split_ifs with h” the branch proofs (the “case pos => …” and “case neg => …”) do not discharge all the subgoals generated by unfolding the definitions. In your “pos” branch, for example, although you use two “constructor” calls and then “exact” tactics, Lean still finds some “unsolved goals” that were left over (or, equivalently, the nesting of the subgoals was not clear enough without using proper bullet notation). The “unexpected identifier” error indicates that Lean thinks you are starting a new tactic or branch when there is still an open goal from the previous case. In short, your tactic script is “under-structured” and Lean’s goal state gets confused.

A recommended fix is to use bullet/indentation notation (or the “·” notation) so that you clearly indicate which tactics belong to which branch. For example, one could rewrite the proof as follows:

----------------------------------------------------------
theorem myMin_spec_satisfied (a b : Int) :
  myMin_spec a b (myMin a b) := by
  unfold myMin myMin_spec
  split_ifs with h
  · -- Case when h : a ≤ b holds
    apply And.intro
    · apply And.intro
      · exact le_refl a
      · exact h
    · exact Or.inl rfl
  · -- Case when ¬(a ≤ b) holds
    have h' : b ≤ a := not_le.mp h
    apply And.intro
    · apply And.intro
      · exact h'
      · exact le_refl b
    · exact Or.inr rfl
----------------------------------------------------------

This version makes explicit (via bullets) which tactics apply to which subgoal. It also replaces the more “magic” sequential constructor calls with explicit applications of And.intro so that Lean’s goal state is managed clearly.

─────────────────────────────  
Conclusion

The error stems from the fact that the tactics in each branch of the “split_ifs” did not completely solve all the subgoals—in particular, the lack of clear bullet structure (or other way to group subgoals) left Lean with “unsolved goals” and later an “unexpected identifier” when a branch label appeared prematurely. To fix this, reorganize your proof using bullet notation (or indentations) so that every subgoal is explicitly addressed and solved. This will help Lean know that the entire goal (both conjuncts, then the nested conjunct) has been completely handled in each branch.