≤ y ∧ ¬ y ≤ x : = by rintro ⟨ h₀, h₁ ⟩ use h₀ exact fun h ' ↦ h₁ ( le _ antisymm h₀ h ' ) in the first example, the semicolon after the constructor command tells lean to use the norm _ num tactic on both of the goals that result. in lean, a ↔ b is not defined to be ( a → b ) ∧ ( b → a ), but it could have been, and it behaves roughly the same way. you have already seen that you can write h. mp and h. mpr or h. 1 and h. 2 for the two directions of h : a ↔ b. you can also use cases and friends. to prove an if - and - only - if statement, you can use constructor or angle brackets, just as you would if you were proving a conjunction. example { x y : ℝ } ( h : x ≤ y ) : ¬ y ≤ x ↔ x = y : = by constructor · contrapose! rintro rfl rfl contrapose! exact le _ antisymm h example { x y : ℝ } ( h : x ≤ y ) : ¬ y ≤ x ↔ x
still want to structure the proof. lean also provides the " bullet " notation. < tactics > ( or · < tactics > ) for structuring proofs : theorem test ( p q : prop ) ( hp : p ) ( hq : q ) : p ∧ q ∧ p : = by apply and. intro. exact hp. apply and. intro. exact hq. exact hp basic tactics in addition to apply and exact, another useful tactic is intro, which introduces a hypothesis. what follows is an example of an identity from propositional logic that we proved in a previous chapter, now proved using tactics. example ( p q r : prop ) : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) : = by apply iff. intro. intro h apply or. elim ( and. right h ). intro hq apply or. inl apply and. intro. exact and. left h. exact hq. intro hr apply or. inr apply and. intro. exact and. left h. exact hr. intro h apply or. elim h. intro hpq apply and. intro. exact and. left hpq. apply or. inl exact and. right hpq. intro hpr apply
##r ; exact this lean also has a let tactic, which is similar to the have tactic, but is used to introduce local definitions instead of auxiliary facts. it is the tactic analogue of a let in a proof term : example : [UNK] x, x + 2 = 8 : = by let a : nat : = 3 * 2 exists a as with have, you can leave the type implicit by writing let a : = 3 * 2. the difference between let and have is that let introduces a local definition in the context, so that the definition of the local declaration can be unfolded in the proof. we have used. to create nested tactic blocks. in a nested block, lean focuses on the first goal, and generates an error if it has not been fully solved at the end of the block. this can be helpful in indicating the separate proofs of multiple subgoals introduced by a tactic. the notation. is whitespace sensitive and relies on the indentation to detect whether the tactic block ends. alternatively, you can define tactic blocks using curly braces and semicolons : example ( p q r : prop ) : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) : = by apply iff. intro {