[CLS] arrays the lean language reference the lean language reference table of contents 1. introduction 2. elaboration and compilation 3. interacting with lean 4. the type system 5. source files and modules 6. namespaces and sections 7. definitions 8. axioms 9. attributes 10. terms 11. type classes 12. coercions 13. tactic proofs 14. functors, monads and do - notation 15. io 16. the simplifier 17. basic propositions 18. basic types 19. notations and macros 20. run - time code 21. build tools and distribution release notes index 18. basic types 18. 1. natural numbers 18. 2. integers 18. 3. finite natural numbers 18. 4. fixed - precision integers 18. 5. bitvectors 18. 6. floating - point numbers 18. 7. characters 18. 8. strings 18. 9. the unit type 18. 10. the empty type 18. 11. booleans 18. 12. optional values 18. 13. tuples 18. 14. sum types 18. 15. linked lists 18. 16. arrays 18. 17. subtypes 18. 18. lazy computations 18. 16. arrays 1. logical model array 2. run
) # check list. length xs # check xs. length as a result, given h : p ∧ q, we can write h. left for and. left h and h. right for and. right h. we can therefore rewrite the sample proof above conveniently as follows : variable ( p q : prop ) example ( h : p ∧ q ) : q ∧ p : = ⟨ h. right, h. left ⟩ there is a fine line between brevity and obfuscation, and omitting information in this way can sometimes make a proof harder to read. but for straightforward constructions like the one above, when the type of h and the goal of the construction are salient, the notation is clean and effective. it is common to iterate constructions like " and. " lean also allows you to flatten nested constructors that associate to the right, so that these two proofs are equivalent : variable ( p q : prop ) example ( h : p ∧ q ) : q ∧ p ∧ q : = ⟨ h. right, ⟨ h. left, h. right ⟩ ⟩ example ( h : p ∧ q ) : q ∧ p ∧ q : = ⟨ h. right, h. left, h. right
still want to structure the proof. lean also provides the " bullet " notation. < tactics > ( or · < tactics > ) for structuring proofs : theorem test ( p q : prop ) ( hp : p ) ( hq : q ) : p ∧ q ∧ p : = by apply and. intro. exact hp. apply and. intro. exact hq. exact hp basic tactics in addition to apply and exact, another useful tactic is intro, which introduces a hypothesis. what follows is an example of an identity from propositional logic that we proved in a previous chapter, now proved using tactics. example ( p q r : prop ) : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) : = by apply iff. intro. intro h apply or. elim ( and. right h ). intro hq apply or. inl apply and. intro. exact and. left h. exact hq. intro hr apply or. inr apply and. intro. exact and. left h. exact hr. intro h apply or. elim h. intro hpq apply and. intro. exact and. left hpq. apply or. inl exact and. right hpq. intro hpr apply