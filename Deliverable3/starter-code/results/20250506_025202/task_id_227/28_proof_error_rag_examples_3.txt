assoc ( a * a ) ] _ = a * a + 2 * ( a * b ) + b * b : = by rw [ mul _ comm b a, ← two _ mul ] notice that the proof does not begin with by : an expression that begins with calc is a proof term. a calc expression can also be used inside a tactic proof, but lean interprets it as the instruction to use the resulting proof term to solve the goal. the calc syntax is finicky : the underscores and justification have to be in the format indicated above. lean uses indentation to determine things like where a block of tactics or a calc block begins and ends ; try changing the indentation in the proof above to see what happens. one way to write a calc proof is to outline it first using the sorry tactic for justification, make sure lean accepts the expression modulo these, and then justify the individual steps using tactics. example : ( a + b ) * ( a + b ) = a * a + 2 * ( a * b ) + b * b : = calc ( a + b ) * ( a + b ) = a * a + b * a + ( a * b +
assoc ( a * a ) ] _ = a * a + 2 * ( a * b ) + b * b : = by rw [ mul _ comm b a, ← two _ mul ] notice that the proof does not begin with by : an expression that begins with calc is a proof term. a calc expression can also be used inside a tactic proof, but lean interprets it as the instruction to use the resulting proof term to solve the goal. the calc syntax is finicky : the underscores and justification have to be in the format indicated above. lean uses indentation to determine things like where a block of tactics or a calc block begins and ends ; try changing the indentation in the proof above to see what happens. one way to write a calc proof is to outline it first using the sorry tactic for justification, make sure lean accepts the expression modulo these, and then justify the individual steps using tactics. example : ( a + b ) * ( a + b ) = a * a + 2 * ( a * b ) + b * b : = calc ( a + b ) * ( a + b ) = a * a + b * a + ( a * b +