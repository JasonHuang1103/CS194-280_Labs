Below is one walkthrough of the error and its causes. (Note that this diagnostic does not “fix” your proof but explains why Lean is failing.)

────────────────────────────── Step 1. Which tactic is failing and why
• The error message begins with
  “error: unsolved goals … ⊢ (∀ i < {…}.size, n > …) ↔ Array.foldl … = true”
in the “case mk” generated by your induction on a. This tells us that after you did

  induction' a using Array.rec with xs ih

Lean expects you to finish the inductive case for the “cons” situation (the nonempty array), but your proof script does not fully discharge that goal. In other words, one or more subgoals remain unsolved.
• Also note the error “unexpected token '·'; expected command” which points to the bullets you used (the “·” tokens). In Lean 4 the bullet commands must be used correctly with proper indentation. The error on token ‘·’ suggests that Lean found one out of place or that the structure of the proof (or separation between tactics) is off.

────────────────────────────── Step 2. What is the proof state at that point?
When the induction is begun by “induction' a using Array.rec with xs ih”, the context looks something like:
  n : ℤ
  a : Array ℤ, which is represented internally as { toList := xs } for some list xs : List ℤ 
  ih : (some inductive hypothesis relating the specification on xs and the foldl value)
with the goal (for the “cons” case) being
  (∀ i, i < {toList := xs}.size → n > {toList := xs}[i]!) ↔
  Array.foldl (fun acc x => acc && decide (n > x)) true {toList := xs} = true.
Your current tactic sequence (using simp, split, intro, etc.) does not completely solve that goal—Lean remains with one unsolved goal (or more), hence the “unsolved goals” error.

────────────────────────────── Step 3. Does the proof approach match the specification?
Your specification is
  (∀ i, i < a.size → n > a[i]!) ↔ result,
and you want to show that if the computed Boolean value using foldl is true then n is greater than every array element (and vice-versa). The general structure (an induction on the array, working with its underlying list representation) makes sense. However:
 – You need an inductive argument that properly ties together foldl’s computation with the universal statement.
 – In the inductive “cons” case you must carefully relate the property over the whole array to that on the tail (the xs from Array.rec).
Missing or incomplete reasoning in these inductive steps is why Lean signals an “unsolved goal.”

────────────────────────────── Step 4. Identify type mismatches or incorrect assumptions
There are two issues here:
1. The bullet notation. The “·” bullets are a shorthand in tactic mode; Lean 4 is very sensitive to indentation and command boundaries. In your script there is a bullet token (“·”) that Lean does not expect at that point (as indicated by “unexpected token '·'”). Make sure that each bullet is at the right indentation level and that you’re not accidentally “introducing” a bullet when a tactic is expected.
2. The term “iot” appears in the line
  rw [iot, Nat.not_lt] at hnlt
This “iot” is not defined anywhere. It is likely a typo or an artifact from a previous version of your proof. (Lean is reporting “unexpected token” when it encounters this.) This may be causing Lean to mis-parse your tactic script, thereby leaving goals unsolved.

Also, note that when you use the array coercions (accessing a[i]!), you are actually using the underlying list (the “toList” field). So your “ih” application and the rewriting should perfectly connect the list folding behavior to the property on indices. If these connections are not done carefully (or if the rewrite rules for Array.foldl are missing), then a type mismatch or an unsolvable goal results.

────────────────────────────── Step 5. Alternative strategies or suggestions
Here are some suggestions to fix or bypass the issue:
• Check your bullet formatting. Make sure that every “·” is correctly indented under its parent tactic and that there is not an extra “·” accidentally introduced where Lean expects a new command.
• Remove or replace the spurious “rw [iot, Nat.not_lt]”. Likely “iot” is a typo. Either remove it or substitute it with the correct lemma or rewriting rule (maybe you meant something like “rw [if_neg]” or to call a previously proven fact).
• Instead of using “induction' a using Array.rec”, consider proving a separate lemma for the folding behavior on lists and then applying this lemma after “unfold isGreater” (since your array’s behavior is defined through foldl on its underlying list). This may allow you to focus on list induction, which is usually less subtle than array induction.
• You might also try a “by cases” proof or explicitly state the two directions (→ and ←) to ensure that the rewriting of “foldl” is well‐controlled.

──────────────────────────── Conclusion: Detailed analysis of the root cause and a direction for fixing it
The root causes are:
 • In the inductive case produced by “induction′ a using Array.rec”, a subgoal remains unsolvable because your proof script does not fully connect the inductive hypothesis (the property of the tail list xs) with the property of the whole array. That is, the tactic sequence using “simp”, “split”, “intro”, and “cases …” fails to close the goal.
 • The proof script contains a typo (the “iot” token) and possible misuses of bullet notation (“·”) from Lean 4: either the bullet markers are mis-indented or inserted where Lean expects an explicit command.
To move forward you should:
1. Correct or remove the mistyped “iot” token.
2. Ensure that the bullet notation is used consistently with proper indentation so that Lean clearly distinguishes each subproof.
3. Consider proving a separate lemma about Array.foldl over the “toList” of the array so that your inductive proof on lists is easier and then “lifting” that result to arrays.
4. Make sure that every direction in the “↔” is handled completely (both the “if” and “only if” parts).

Following these directions should help you get past the “unsolved goals” and “unexpected token” errors in Lean 4.