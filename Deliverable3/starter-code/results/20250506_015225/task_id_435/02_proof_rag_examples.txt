still want to structure the proof. lean also provides the " bullet " notation. < tactics > ( or · < tactics > ) for structuring proofs : theorem test ( p q : prop ) ( hp : p ) ( hq : q ) : p ∧ q ∧ p : = by apply and. intro. exact hp. apply and. intro. exact hq. exact hp basic tactics in addition to apply and exact, another useful tactic is intro, which introduces a hypothesis. what follows is an example of an identity from propositional logic that we proved in a previous chapter, now proved using tactics. example ( p q r : prop ) : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) : = by apply iff. intro. intro h apply or. elim ( and. right h ). intro hq apply or. inl apply and. intro. exact and. left h. exact hq. intro hr apply or. inr apply and. intro. exact and. left h. exact hr. intro h apply or. elim h. intro hpq apply and. intro. exact and. left hpq. apply or. inl exact and. right hpq. intro hpr apply
still want to structure the proof. lean also provides the " bullet " notation. < tactics > ( or · < tactics > ) for structuring proofs : theorem test ( p q : prop ) ( hp : p ) ( hq : q ) : p ∧ q ∧ p : = by apply and. intro. exact hp. apply and. intro. exact hq. exact hp basic tactics in addition to apply and exact, another useful tactic is intro, which introduces a hypothesis. what follows is an example of an identity from propositional logic that we proved in a previous chapter, now proved using tactics. example ( p q r : prop ) : p ∧ ( q ∨ r ) ↔ ( p ∧ q ) ∨ ( p ∧ r ) : = by apply iff. intro. intro h apply or. elim ( and. right h ). intro hq apply or. inl apply and. intro. exact and. left h. exact hq. intro hr apply or. inr apply and. intro. exact and. left h. exact hr. intro h apply or. elim h. intro hpq apply and. intro. exact and. left hpq. apply or. inl exact and. right hpq. intro hpr apply
[CLS] learn lean 4 in y minutes share this page learn x in y minutes where x = lean 4 get the code : learnlean4. lean lean 4 is a dependently typed functional programming language and an interactive theorem prover. / - an enumerated data type. - / inductive grade where | a : grade | b : grade | f : grade deriving repr / - functions. - / def grade ( m : nat ) : grade : = if 80 < = m then grade. a else if 60 < = m then grade. b else grade. f def highmarks : = 80 + 9 def lowmarks : = 25 + 25 # eval grade highmarks # eval grade lowmarks # check ( 0 : nat ) / - # check ( 0 : grade ) - / / - this is an error. - / / - types themselves are values. - / # check ( nat : type ) / - mathematical propositions are values in lean. ` prop ` is the type of propositions. here are some simple propositions. - / # check 0 = 1 # check 1 = 1 # check 2 ^ 9 - 2 ^ 8 = 2 ^ 8 / - notice lean displays ` 0 = 1 : prop ` to say :