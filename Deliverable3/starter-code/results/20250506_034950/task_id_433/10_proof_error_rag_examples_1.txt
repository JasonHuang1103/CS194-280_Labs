[CLS] learn lean 4 in y minutes share this page learn x in y minutes where x = lean 4 get the code : learnlean4. lean lean 4 is a dependently typed functional programming language and an interactive theorem prover. / - an enumerated data type. - / inductive grade where | a : grade | b : grade | f : grade deriving repr / - functions. - / def grade ( m : nat ) : grade : = if 80 < = m then grade. a else if 60 < = m then grade. b else grade. f def highmarks : = 80 + 9 def lowmarks : = 25 + 25 # eval grade highmarks # eval grade lowmarks # check ( 0 : nat ) / - # check ( 0 : grade ) - / / - this is an error. - / / - types themselves are values. - / # check ( nat : type ) / - mathematical propositions are values in lean. ` prop ` is the type of propositions. here are some simple propositions. - / # check 0 = 1 # check 1 = 1 # check 2 ^ 9 - 2 ^ 8 = 2 ^ 8 / - notice lean displays ` 0 = 1 : prop ` to say :
assoc ( a * a ) ] _ = a * a + 2 * ( a * b ) + b * b : = by rw [ mul _ comm b a, ← two _ mul ] notice that the proof does not begin with by : an expression that begins with calc is a proof term. a calc expression can also be used inside a tactic proof, but lean interprets it as the instruction to use the resulting proof term to solve the goal. the calc syntax is finicky : the underscores and justification have to be in the format indicated above. lean uses indentation to determine things like where a block of tactics or a calc block begins and ends ; try changing the indentation in the proof above to see what happens. one way to write a calc proof is to outline it first using the sorry tactic for justification, make sure lean accepts the expression modulo these, and then justify the individual steps using tactics. example : ( a + b ) * ( a + b ) = a * a + 2 * ( a * b ) + b * b : = calc ( a + b ) * ( a + b ) = a * a + b * a + ( a * b +