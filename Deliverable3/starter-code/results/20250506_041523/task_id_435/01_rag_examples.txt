function is total. - / def prime ( n : nat ) : bool : = if n < 2 then true else go ( n - 1 ) n where go d n : = if d < 2 then true else if n % d = 0 then false else go ( d - 1 ) n / - now, to lean, it is obvious that ` go ` will terminate because ` d ` decreases in each recursive call. - / # eval prime 57 # eval prime 97 for further learning, see : functional programming in lean theorem proving in lean 4 lean 4 manual got a suggestion? a correction, perhaps? open an issue on the github repo, or make a pull request yourself! originally contributed by balagopal komarath, and updated by 3 contributors. © 2025 balagopal komarath, ferinko [SEP]
an h₀ and a h₁, whereas second pattern, with the bar, matches against data that contains either an h₀ or h₁. in this case, because the two goals are separate, we have chosen to use the same name, h, in each case. the absolute value function is defined in such a way that we can immediately prove that x ≥ 0 implies | x | = x ( this is the theorem abs _ of _ nonneg ) and x < 0 implies | x | = - x ( this is abs _ of _ neg ). the expression le _ or _ gt 0 x establishes 0 ≤ x ∨ x < 0, allowing us to split on those two cases. lean also supports the computer scientists ’ pattern - matching syntax for disjunction. now the cases tactic is more attractive, because it allows us to name each case, and name the hypothesis that is introduced closer to where it is used. example : x < | y | → x < y ∨ x < - y : = by cases le _ or _ gt 0 y case inl h = > rw [ abs _ of _ nonneg h ] intro h ; left ; exact h case inr h = > rw [ abs _ of _ ne
[CLS] learn lean 4 in y minutes share this page learn x in y minutes where x = lean 4 get the code : learnlean4. lean lean 4 is a dependently typed functional programming language and an interactive theorem prover. / - an enumerated data type. - / inductive grade where | a : grade | b : grade | f : grade deriving repr / - functions. - / def grade ( m : nat ) : grade : = if 80 < = m then grade. a else if 60 < = m then grade. b else grade. f def highmarks : = 80 + 9 def lowmarks : = 25 + 25 # eval grade highmarks # eval grade lowmarks # check ( 0 : nat ) / - # check ( 0 : grade ) - / / - this is an error. - / / - types themselves are values. - / # check ( nat : type ) / - mathematical propositions are values in lean. ` prop ` is the type of propositions. here are some simple propositions. - / # check 0 = 1 # check 1 = 1 # check 2 ^ 9 - 2 ^ 8 = 2 ^ 8 / - notice lean displays ` 0 = 1 : prop ` to say :