[CLS] arrays the lean language reference the lean language reference table of contents 1. introduction 2. elaboration and compilation 3. interacting with lean 4. the type system 5. source files and modules 6. namespaces and sections 7. definitions 8. axioms 9. attributes 10. terms 11. type classes 12. coercions 13. tactic proofs 14. functors, monads and do - notation 15. io 16. the simplifier 17. basic propositions 18. basic types 19. notations and macros 20. run - time code 21. build tools and distribution release notes index 18. basic types 18. 1. natural numbers 18. 2. integers 18. 3. finite natural numbers 18. 4. fixed - precision integers 18. 5. bitvectors 18. 6. floating - point numbers 18. 7. characters 18. 8. strings 18. 9. the unit type 18. 10. the empty type 18. 11. booleans 18. 12. optional values 18. 13. tuples 18. 14. sum types 18. 15. linked lists 18. 16. arrays 18. 17. subtypes 18. 18. lazy computations 18. 16. arrays 1. logical model array 2. run
[CLS] arrays the lean language reference the lean language reference table of contents 1. introduction 2. elaboration and compilation 3. interacting with lean 4. the type system 5. source files and modules 6. namespaces and sections 7. definitions 8. axioms 9. attributes 10. terms 11. type classes 12. coercions 13. tactic proofs 14. functors, monads and do - notation 15. io 16. the simplifier 17. basic propositions 18. basic types 19. notations and macros 20. run - time code 21. build tools and distribution release notes index 18. basic types 18. 1. natural numbers 18. 2. integers 18. 3. finite natural numbers 18. 4. fixed - precision integers 18. 5. bitvectors 18. 6. floating - point numbers 18. 7. characters 18. 8. strings 18. 9. the unit type 18. 10. the empty type 18. 11. booleans 18. 12. optional values 18. 13. tuples 18. 14. sum types 18. 15. linked lists 18. 16. arrays 18. 17. subtypes 18. 18. lazy computations 18. 16. arrays 1. logical model array 2. run
##h = > simp [ splitlist ] unsolved goals case cons α : type u _ 1 x : α xs : list α ih : ( splitlist xs ). fst. length ≤ xs. length ∧ ( splitlist xs ). snd. length ≤ xs. length [UNK] ( splitlist xs ). snd. length ≤ xs. length ∧ ( splitlist xs ). fst. length ≤ xs. length + 1 this is because the call to list. length consumes the head of the list x : : xs, converting it to a nat. succ, in both the length of the input list and the length of the first output list. writing a ∧ b in lean is short for and a b. and is a structure type in the prop universe : structure and ( a b : prop ) : prop where intro : : left : a right : b in other words, a proof of a ∧ b consists of the and. intro constructor applied to a proof of a in the left field and a proof of b in the right field. the cases tactic allows a proof to consider each constructor of a datatype or each potential proof of a proposition in turn.